---
title: "Introduction à C++"
author: "Victor Cameron & Benjamin Mercier"
date: "18/09/2020"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Pourquoi C++?

La probabilité $X_i$ qu'une cellule $i$ soit occupée par une population est la somme de la probabilité de colonisation et de la probabilité qu'une population y demeure

$$P(X_{i,t+1} = 1) = c_i + (1 - e_i)$$

où la probabilité de colonisation de $i$ est la somme des probabilités qu'un colonisateur arrive de $j$ et est fonction de la distance $D_{ij}$.

$$c_i = \sum{X_j * f(D_{ij})}$$

La distance entre la cellule $j$ et $i$ doit être calculé à chaque itération, parce que la matrice de distance serait trop volumineuse à garder en mémoire

Problème! Le paysage contient 10^{5} cellules, donc chaque intération représente 10^{10} calculs de distance.

### Comparons le temps nécessaire pour faire l'opération en R et en C++

Fonction qui calcule la sommation des distances Euclédiennes pour les cellules de la matrice avec R

```{r distances}
distanceR <- function(width, height, x_vec, y_vec){

  distance <- matrix(0, nc = width, nr = height)

  # Cellule [y_i,x_i]
  for(x_i in x_vec){
    for(y_i in y_vec){

      dist <- 0

      # Cellule [y_j,x_j]
      for(x_j in x_vec){
        for(y_j in y_vec){
          dist <- dist + sqrt((x_i - x_j)^2 + (y_i - y_j)^2)
        }
      }

      distance[y_i,x_i] <- dist
    }
  }
}
```

Fonction qui calcule la sommation des distances Euclédiennes pour les cellules de la matrice avec C++

```{Rcpp}
#include <string.h>
#include <numeric>
#include <math.h>
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericMatrix distanceCpp(int width, int height, NumericVector x_vec, NumericVector y_vec) {

    NumericMatrix distance(height, width);   // height x width matrix
    float dist;

    // Cellule [y_i,x_i]
    for(int x_i=0; x_i<width; x_i++){ // En C++ le premier élément d un vecteur est à la position 0
    for(int y_i=0; y_i<height; y_i++){ // C++ a obtenu son nom de la commande y++

      dist = 0;  // somme des distances pour la cellule [y_i,x_i]

      // Cellule [y_j,x_j]
      for(int x_j=0; x_j<width; x_j++){
        for(int y_j=0; y_j<height; y_j++){

          dist += sqrt((x_i - x_j)^2 + (y_i - y_j)^2); // += est l équivalent de dist = dist + sum

        }
      }

      distance(y_i,x_i) = dist;

    }
  }

  return distance;

}

```

Comparons le temps nécessaire pour faire l'opération en R et en C++

```{r}
# Prenons une matrice de 100 x 10 cellules
width <- 100
height <- 10

# Deux vecteurs décrivant la position en x et en y des cellules d'une matrice de 100x10 cellules
x_vec <- c(1:width)
y_vec <- c(1:height)

# Temps requis pour compléter l'opération
system.time({distanceR(width, height, x_vec, y_vec)})  # Avec R
system.time({distanceCpp(width, height, x_vec, y_vec)}) # Avec C++
```

La rapidité d'implémentation du langage de programmation C++ est de beaucoup suppérieure à celle de R. Cependant, programmer en R est beaucoup plus convivial. Voyons comment.

***Allocation de la mémoire!***
R mets beaucoup de temps en allocation de mémoire et crée de nombreux objets temporaires.
C++ permet une implémentation plus rapide puisqu'il permet d'optimiser via la gestion de la mémoire et des 'patterns' d'accès.

## Une courte histoire de C++

Provient de C


## Un survol de C++

Exemple de script
```{Rcpp, eval = FALSE}
/* C++ est un langage compilé
*/

#include <iostream.h>

main(){
  
  std::cout << "Ceci est un programme en C++";
  
  return 0;
}
```

C++ est un langage compilé. C'est à dire qu'il doit être compilé par un compilateur avant de pouvoir être 'runné'

__/*__ __*/__ ou __//__ marque un commentaire

__#include <iostream.h>__ fait appel à la librairie iostream qui permet d'utiliser la commande __cout__

__main()__ c'est où l'exécution du programme commence. Tous les programmes C++ sont composés d'une ou de plusieurs fonctions. Ici, la fonction est nommée __main()__. Tous les programmes en C++ doivent contenir une fonction __main()__ qui indique le début et la fin du code à exécuter.

__std::__ fait appel au namespace utilisé. Peut être remplacé par __using namespace std;__

__cout << "Ceci est un programme en C++";__ est la déclaration de la sortie de la console. L'oppérateur __<<__ cause ce qui est à sa droite à être la sortie de l'identifiant à sa gauche. __cout__ est un identifiant prédéfini qui cause le message à être imprimé à l'écran.

__return 0;__ met fin à __main()__ et retourne la valeur 0 au système d'opération ce qui signifie que le programme se termine normalement. si d'autres valeurs sont retournées, cela signifie que le programme s'est terminé à cause d'une erreur.

Toutes les commandes se terminent par un point virgue __;__

### La fonction en C++

_type_retour nom_fonction(liste des paramètres)_
_{_
_corps de la fonction_
_}_

```{Rcpp, eval = FALSE}
// exemple de fonction qui retourne une valeur

```

**Void functions

### Déclaration de variable

_type variable_list;_

Les variables peuvent êtres locales ou globales, comme dans R

### Boucle for()

### if() statement

### Les opérateurs

| Opérateur | Action |
| :-------- | -----: |
| -         | soustraction|
| + | addition |
| * | multiplication |
| / | division |
| % | modulus |
| -- | décrément |
| ++ | incrément |

C++ a obtenu son nom de l'opérateur d'incrément. C++ est bâti à partir du langage C, il représente un _incremental improvment_ par rapport à C

## Rcpp
